'use strict';

//const arr = [5, 5, 5];

//function grvr() {
    
//}

//const str = "dfghhffds";

// установила расширение eslint
// npm init
// npm init @eslint/config

// появились файлы package-lock.json, package.json, .eslintrc.js
// в .eslintrc.js комментирую // "extends": "eslint:recommended",


//урок 21. Логические операторы (33 минуты)


//script.js


// const hamburger = true;
// const fries = true;

// if (hamburger && fries) {
//     console.log('Я сыт!');
// } 
//Я сыт! так как условие выполнено и hamburger true & fries true


// console.log((hamburger && fries)); //true просто вернуло логический тип данных, результат логических операций - логическое булевое значение
// если одно из блюд будет отсутствовать мы получим false


// const hamburger = true;
// const fries = false;

// if (hamburger && fries) {
//     console.log('Я сыт!');
// } //результата нет в консоли потому что условие не выполнилось а блока else нет


// const hamburger = true;
// const fries = false;

// if (hamburger && fries) {
//     console.log('Я сыт!');
// }
// console.log((hamburger && fries)); // false


// const hamburger = 5;
// const fries = 0;

// if (hamburger && fries) {
//     console.log('Я сыт!');
// }
// //ответа нет так как условие не может быть выполнено, это подводит к теме "динамическая типизация в джаваскрипте" которую будем изучать позднее, строка может стать числом, число может стать строкой, что угодно может стать логическим значением
// humburger & fries нужно если сайт будет по продаже товаров, показывать пользователю информацию сколько товаров есть на сайте и что делать если нет картошки и вместо сообщения "я сыт" пользователю будет написано "товар закончился на складе"

// пять сущностей которые всегда будут false: 
// 0, 
// пустая строка "", 
// null(нулевой), 
// undefined(неопределенный), 
// NaN (not a number - не число)
// все остальное всегда будет true

// таблица приоритетов операторов https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Operator_Precedence

// строго равно === это пункт 10,
// логическое И && это пункт 6
// приоритет 20 самый высокий, значит вначале выполнится пункт 10 строго равно, а только потом пункт 6 логическое и, пункт 1 внизу и выполняется самым последним


// const hamburger = 2;
// const fries = 1;

// if (hamburger === 3 && fries === 1) {
//     console.log('Все сыты!');
// } else {
//     console.log('Мы уходим');
// } // так как в кафе есть только 2 гамбургера и 1 картошка, а нам надо 3 гамбургера и 1 картошку - условие не выполнено (мы не получаем что хотим) поэтому - мы уходим. так же можно было в скобках условия if написать (hamburger === 3 && fries)


// const hamburger = 2;
// const fries = 1;

// if (hamburger === 3 && fries === 1) {
//     console.log('Все сыты!');
// } else {
//     console.log('Мы уходим');
// } // так как в кафе есть только 2 гамбургера и 1 картошка, а нам надо 3 гамбургера и 1 картошку - условие не выполнено (мы не получаем что хотим) поэтому - мы уходим. так же можно было в скобках условия if написать (hamburger === 3 && fries)


// оператор И возвращает первое ложное значение на котором он остановил свою работу:
// const hamburger = 3;
// const fries = 1;
// const cola = 0;

// console.log(hamburger === 3 && cola && fries) //0 (это значение колы)

// console.log(1 && 0); //0 так как 1 это всегда true, а 0 это всегда false а значит ноль

// console.log(1 && 5); // true и консоль возвращает последнее значение а это 5

// console.log(null && 5);// null - сравниваем неправду (нул это ничего) и что-то и консоль возвращает первое неправильное значение false

// console.log(0 && 'hdxtyhjx');//0 - сравниваем 0 неправду false и строку и поэтому получаем ноль потому что оператор && и запнулся на первом неправдивом значении


// и запинается на лжи, или запинается на правде


// const hamburger = 3;
// const fries = 0;
// const cola = 0;

// if (hamburger || cola || fries) {
//     console.log('Все довольны!');
// } else {
//     console.log('Мы уходим');
// }
// // Все довольны! (так как нам нужен гамбургер или кола или картошка)


// const hamburger = 0;
// const fries = 0;
// const cola = 0;

// if (hamburger || cola || fries) {
//     console.log('Все довольны!');
// } else {
//     console.log('Мы уходим');
// }
// // Мы уходим (так как условие не выполнилось, нам нужен гамбургер или кола или картошка)


// const hamburger = 0;
// const fries = null;
// const cola = 0;

// if (hamburger || cola || fries) {
//     console.log('Все довольны!');
// } else {
//     console.log('Мы уходим');
// }

// console.log(hamburger | | cola | | fries);
// // 
// Мы уходим 
// null
// последнее значение которое возвращает ложь это fries и его ответ это null


// let johnReport, alexReport, samReport, mariaReport = 'done';
// console.log(johnReport | | alexReport | | samReport | | mariaReport); //done


// приоритет операторов:
// вначале сравнение строго равно === пункт 10
// потом логическое И && пункт 6
// и только потом логическое ИЛИ | | пункт 5


// const hamburger = 3;
// const fries = 3;
// const cola = 0;
// const nuggets = 2;

// if (hamburger === 3 && cola === 2 | | fries === 3 && nuggets) {
//     console.log('Все довольны');
// } else {
//     console.log('Мы уходим');
// } //Все довольны
// (правда и неправда) или (правда и правда)
// false или true


// const hamburger = 3;
// const fries = 3;
// const cola = 0;
// const nuggets = 2;

// console.log(hamburger === 3 && cola === 2 || fries === 3 && nuggets); //2
// //правда и неправда это false про этот кусок забываем и смотрим на правый кусок там правда и правда, первая правда = 3, вторая правда = 2 и в итоге консольлог возвращает ответом последнюю правду = 2 (сравнивает левый кусок там ложь и правый кусок там два и возвращает первое правдивое выражение = 2)


// самый высокий приоритет у скобок ( )
// например
// console.log(hamburger === 3 && (cola === 2 | | fries === 3) && nuggets);
// то порядок операторов поменяется 
// вначале сравнение (кола=2 нет) или (фри=3 да)


// оператор не !
// console.log(!0); //true
// не ноль
// вначале аргумент к которому он применен он превращает в логический тип данных либо тру либо фолз и после этого оператор возвращает противоположное значение


//доделала урок 21 логические операторы 33 минуты (делала минимум 4 помидора)
//петриченко предлагает сделать в консоли задачи (делала минимум 2 помидора)

//console.log(NaN || 2 || undefined ); //2 так как не число или 2 или неопределенный единственное тру возвращается 2

// console.log( NaN && 2 && undefined ); //NaN так как не число и 2 и неопределенный - И запинается на первой лжи?

//console.log( 1 && 2 && 3 ); //3-1и2и3 вернуло последнее значение?

//console.log( !1 && 2 || !3 ); //false - 
//!-логическое отрицание НЕ 1 (пункт14)
//&&-логическое И (пункт4)
//||-логическое ИЛИ (пункт3)
//!-логическое отрицание НЕ 3 (пункт14)
//вначале читаем НЕ1 И 2 ИЛИ НЕ3 

//console.log( 25 || null && !3 ); //25
//25
//ИЛИ
//null-обозначение отсутствия значения (не ноль) 
//И
//НЕ3
//25 ИЛИ отсуствие значения И НЕ 3 = 25

//console.log( NaN || null || !3 || undefined || 5 );//5
//NaN - не число
//null-обозначение отстуствия значения (не ноль) (умышленное отстуствие значения)
//!3 = НЕ 3
//undefined -не определено значение (неожиданное отстуствие значения)
//5
//не число ИЛИ отсутствует значение ИЛИ не3 ИЛИ не определено значение ИЛИ 5 = 5
//у логического отрицания ! приоритет выше чем у ИЛИ ||

//console.log( NaN || null && !3 && undefined || 5 );//5
//&& логическое И приоритет выше чем у || лигическое ИЛИ
//у НЕ ! самый высокий приоритет
//отсутствие значение И не3 И не определено значение ИЛИ не число ИЛИ 5 = 5

//console.log( 5 === 5 && 3 > 1 || 5 );//true
//> больше пункт 9
//=== строгое равенство пункт 8
//&& логическое И пункт 4
//|| логическое ИЛИ пункт 3
//итого 5 строго равно 5 И 3 больше 1 ИЛИ 5 = true И true ИЛИ 5 = true

// const hamburger = 3;
// const fries = 3;
// const cola = 0;
// const nuggets = 2;

// if (hamburger === 3 && cola || fries === 3 && nuggets) {
// 	console.log('Done!');
// }
//Done! если гамбургеров 3 и 1 кола ИЛИ 3 фри и 1 наггетс = done

// let hamburger;
// const fries = NaN;
// const cola = 0;
// const nuggets = 2;

// if (hamburger || cola || fries === 3 || nuggets) {
// 	console.log('Done!');
// }
//Done! 
//=== строгое равенство пункт 8 (вначале фри = 3 false)
//|| логическое ИЛИ пункт 3 (потом 1 гамбургер фолз ИЛИ 1 кола фолз ИЛИ 3 фри фолз ИЛИ 1 наггетс тру - есть одно тру значит Done)
//переменная hamburger задана через let так как const требует какое-либо начальное значение, если const hamburger;-будет ошибка так как без значения там undefined - неожиданное отстутствие значения

// let hamburger;
// const fries = NaN;
// const cola = 0;
// const nuggets = 2;

// if (hamburger && cola || fries === 3 && nuggets) {
// 	console.log('Done!');
// }
//нет ответа
//=== строгое равенство пункт8 - вначале выполняется фри=3 это фолз
//&& логическое И пункт4 - потом выполняется гамбургер=1 и кола=1 это фолз, фри=3 и 1 наггетс это фолз
//|| логическое ИЛИ пункт3 - потом выполняется фолз или фолз

// const hamburger = 1;
// const fries = 1;
// const cola = 1;
// const nuggets = 2;

// if (hamburger && cola || fries === 3 && nuggets) {
// 	console.log('Done!');
// }
//Done


//урок 23 цикл в цикле и метки


// for (let i = 0; i < 3; i++) {
// 	console.log(i);
// 	for (let j = 0; j < 3; j++) {
// 		console.log(j);
// 	}
// }
// //0 - первый цикл
// //0 - второй цикл
// //1 - второй цикл
// //2 - второй цикл доходит до 2 меньше 3
// //1 - первый цикл 0+1=1
// //0 - начинается второй цикл
// //1 - второй цикл
// //2 - второй цикл доходит до 2 меньше 3
// //2 - начинается первый цикл 1+1=2 (первый цикл дает ответ в последний раз, i = 2 это меньше 3)
// //0 - начинается второй цикл с 0
// //1 - второй цикл
// //2 - второй цикл доходит до j= 2 это меньше 3, а первый цикл не начинается потому что он уже вернул ранее 2 меньше 3


// let result = '';
// const length = 7;

// for (let i = 1; i < length; i++) {

// 	for (let j = 0; j < i; j++) {
// 		result += '*';
// 	}

// 	result += '\n';
// }

// console.log(result);
// //*
// //**
// //***
// //****
// //*****
// //******


// first: for (let i = 0; i < 3; i++) {
// 	console.log(`First level: ${i}`);
// 	for (let j = 0; j < 3; j++) {
// 		console.log(`Second level: ${j}`);
// 		for (let k = 0; k < 3; k++) {
// 			if (k === 2) continue first;
// 			console.log(`Third level: ${k}`);
// 		}
// 	}
// }
// //First level: 0
// //Second level: 0
// //Third level: 0
// //Third level: 1
// //First level: 1
// //Second level: 0
// //Third level: 0
// //Third level: 1
// //First level: 2
// //Second level: 0
// //Third level: 0
// //Third level: 1
// //третий уровень доходит только до 1 меньше 2


// first: for (let i = 0; i < 3; i++) {
// 	console.log(`First level: ${i}`);
// 	for (let j = 0; j < 3; j++) {
// 		console.log(`Second level: ${j}`);
// 		for (let k = 0; k < 3; k++) {
// 			if (k === 2) break first;
// 			console.log(`Third level: ${k}`);
// 		}
// 	}
// }
// //First level: 0
// //Second level: 0
// //Third level: 0
// //Third level: 1


// //Задачи:


// //При помощи цикла выведите числа от 5 до 10 в консоль. 5 и 10 включительно. Цикл можно использовать любой
// for (let i = 5; i < 11; i++) {
// 	console.log(i);
// }
// //5
// //6
// //7
// //8
// //9
// //10


// //При помощи цикла for вывести числа от 20 до 10 в консоль. В обратном порядке (20, 19, 18...). Когда цикл дойдет до числа 13 - остановить весь цикл
// first: for (let i = 20; i >= 10; i--) {
// 	if (i === 13) break first;
// 	console.log(i);
// }
// //20
// //19
// //18
// //17
// //16
// //15
// //14


// //При помощи цикла for выведите чётные числа от 2 до 10 включительно
// for (let i = 2; i <= 10; i++) {
// 	if (i % 2 === 0) {
// 		console.log(i);
// 	}
// }
// //2
// //4
// //6
// //8
// //10


// //Перепишите цикл  for на вариант с while. Результат должен остаться точно таким же. Не создайте бесконечный цикл! Иначе браузер может зависнуть.
// //Цикл, который нужно переписать:
// for (let i = 2; i <= 16; i++) {
// 	if (i % 2 === 0) {
// 		continue;
// 	} else {
// 		console.log(i);
// 	}
// }
// //3
// //5
// //7
// //9
// //11
// //13
// //15
// let i = 2;
// while (i <= 16) {
// 	if (i % 2 === 0) {
// 		i++;
// 		continue;
// 	} else {
// 		console.log(i);
// 	}
// 	i++;
// }
// //3
// //5
// //7
// //9
// //11
// //13
// //15


// //Заполните массив цифрами от 5 до 10 включительно. Помните, что элементы массива можно сформировать так же, как и обращаться к ним: arr[0]
// const arrayOfNumbers = [];
// for (let i = 5; i < 11; i++) {
// 	arrayOfNumbers[i - 5] = i;
// }
// console.log(arrayOfNumbers);
// return arrayOfNumbers; 
// //parding error: 'return'outside of funstion eslint - добавила в .eslintrc.js в parserOptions - ecmaFeatures - globalReturn true
// //[ 5, 6, 7, 8, 9, 10 ]


//упражнение по написанию кода 4 * продвинутые задания на использование циклов и условий
//Задачи:


// //1. Заполните новый массив (result) числами из старого (arr). Количество элементов в массиве можно получить как arr.length, а к элементам обращаемся все так же: arr[0], arr[1] и тд. Должен получиться точно такой же массив
// // Место для первой задачи
// // Значения массива менять нельзя, тут он проверяется автоматически именно на эти значения
// const arr = [3, 5, 8, 16, 20, 23, 50];
// const result = [];
// for (let i = 0; i < arr.length; i++) {
// 	result[i] = arr[i];
// }
// console.log(result);
// return result;
// //[
// //    3,  5,  8, 16,
// //   20, 23, 50
// // ]


// // 2.Измените данный массив так, чтобы все числа были увеличены в 2 раза, а если попадается строка строка - то к ней было добавлено " - done".
// // Для определения типа данных используйте typeof();
// // Должно получиться: [ 10, 20, 'Shopping - done', 40, 'Homework - done' ]
// // Место для второй задачи
// // Значения массива менять нельзя, тут он проверяется автоматически именно на эти значения
// const data = [5, 10, 'Shopping', 20, 'Homework'];
// for (let i = 0; i < data.length; i++) {
// 	if (typeof(data[i]) === 'number') {
// 		data[i] = data[i] * 2;
// 	} else if (typeof(data[i]) === 'string') {
// 		data[i] = `${data[i]} - done`;
// 	}
// }
// console.log(data); 
// return data;
// //[ 10, 20, 'Shopping - done', 40, 'Homework - done' ]


// //3. Разверните массив data наоборот при помощи цикла и запишите данные в массив result. 
// //Должно получиться: [ 'Homework', 20, 'Shopping', 10, 5 ]
// // Место для третьей задачи
// // Значения массива менять нельзя, тут он проверяется автоматически именно на эти значения
// const data = [5, 10, 'Shopping', 20, 'Homework'];
// const result = [];

// for (let i = 1; i <= data.length; i++) {
// 	result[i - 1] = data[data.length - i];
// }
    
// console.log(result);
// return result;
// //[ 'Homework', 20, 'Shopping', 10, 5 ]


// ///упражнение по написанию кода 5 ** задача на формирование фигуры
// //Сейчас вам необходимо написать код, который при помощи звездочек (*) в консоли нарисует вот такую фигуру:
// //     *
// //    ***
// //   *****
// //  *******
// // *********
// //***********
// //Подсказка: в конце фигуры есть перенос строки \n, который тоже учитывается в тестах. 
// //В КОНЦЕ КАЖДОЙ СТРОКИ НЕТ ПРОБЕЛОВ, ТОЛЬКО ПЕРЕНОС
// // Проверяется именно переменная result, формируйте строку в ней
// const lines = 5;
// let result = '';
// for (let i = 0; i <= lines; i++) {
// 	for (let j = 0; j < lines - i; j++) {
// 		result += ' ';
// 	}
// 	for (let k = 0; k < 2 * i + 1; k++) {
// 		result += '*';
// 	}
// 	result += '\n';
// }
// console.log(result);


// const usdCurr = 28;
// const eurCurr = 32;

// function convert(amount, curr) {
//     console.log(curr * amount);
// }

// convert(500, usdCurr); //500*28=14000
// convert(500, eurCurr); //500*32=16000

// // Упражнение по написанию кода 7:(*) Продвинутые задания на использование функций

// //Задачи:

// //1) Создайте функцию, которая будет вычислять объем и площадь полной поверхности куба (тоже базовая математика, иногда используется в создании анимаций). Эта функция принимает в себя целое число со значением длины ребра куба. Ответ выведите в формате строки, который изображен в примерах.
// //Если в функцию попал неправильный аргумент или вычислить значения невозможно - вернуть строку "При вычислении произошла ошибка"
// //НЕ ИСПОЛЬЗУЙТЕ ОПЕРАТОР СТЕПЕНИ ** - в онлайн среде браузера он не работает и тесты будут ломаться. Это из-за того, что этот оператор из более нового стандарта, чем тут доступен.
// //Примеры:
// //calculateVolumeAndArea(5)  => 'Объем куба: 125, площадь всей поверхности: 150'
// //calculateVolumeAndArea(15)  => 'Объем куба: 3375, площадь всей поверхности: 1350'
// //calculateVolumeAndArea(15.5)  => 'При вычислении произошла ошибка'
// //calculateVolumeAndArea('15')  => 'При вычислении произошла ошибка'
// //calculateVolumeAndArea(-15)  => 'При вычислении произошла ошибка'

// function calculateVolumeAndArea(length) {
//     if (typeof (length) !== 'number' || length < 0 || !Number.isInteger(length)) {
//         return "При вычислении произошла ошибка";
//     }

//     let volume = 0;
//     let area = 0;

//     volume = length * length * length; 
//     //length ** 3 - тоже самое, ** - оператор степени, но онлайн редактор его не понимает
//     area = 6 * (length * length);

//     return `Объем куба: ${volume}, площадь всей поверхности: ${area}`;
// }

// calculateVolumeAndArea(5);
// calculateVolumeAndArea(15);
// calculateVolumeAndArea(15.5);
// calculateVolumeAndArea('15');
// calculateVolumeAndArea(-15);

// //Expected 'Объем куба: 0, площадь всей поверхности: 0' to equal 'Объем куба: 125, площадь всей поверхности: 150'.
// //Expected-Ожидал, to equal-в равной
// //забыла length в скобках function calculateVolumeAndArea(length) {

// //2) Напишите функцию, которая будет определять номер купе по переданному ей номеру места. 
// //Функция принимает только целое число от 1 до 36.
// //Если переданный аргумент не число, отрицательное или дробное - возвращается сообщение: "Ошибка. Проверьте правильность введенного номера места"
// //Если число 0 или больше 36, то сообщение: "Таких мест в вагоне не существует"
// //Пример:
// //getCoupeNumber(33)  => 9
// //getCoupeNumber(7)  => 2
// //getCoupeNumber(300)  => "Таких мест в вагоне не существует"
// //getCoupeNumber(0)  => "Таких мест в вагоне не существует"
// //getCoupeNumber(7.7)  => "Ошибка. Проверьте правильность введенного номера места"
// //getCoupeNumber(-10)  => "Ошибка. Проверьте правильность введенного номера места"
// //getCoupeNumber('Hello')  => "Ошибка. Проверьте правильность введенного номера места"

// function getCoupeNumber(seatNumber) {
//     if (typeof (seatNumber) !== 'number' || seatNumber < 0 || !Number.isInteger(seatNumber)) {
//         return "Ошибка. Проверьте правильность введенного номера места";
//     }

//     if (seatNumber === 0 || seatNumber > 36) {
//         return "Таких мест в вагоне не существует";
//     }

//     return Math.ceil(seatNumber / 4);
// }

// getCoupeNumber(33);
// //typeof (оператор возвращает строку указывающую тип операнда 42-number, 'blubber'-string, true-boolean, undeclaredVariable-undefined)
// //sInteger() определяет, является ли значение целым числом.

// //создаю функцию getCoupeNumber с аргументом seatNumber
// //если тип данных аргумента не номер И аргумент меньше нуля И аргумент НЕ является целым числом - ТОГДА ОШИБКА
// //если аргумент строго равно 0 И больше 36 - НЕ СУЩЕСТВУЕТ
// //вернуть округление дробного числа до целого всегда в большую сторону значение аргумента деленное на 4 это будет номер купе
// //вызов функции


// Упражнение по написанию кода 8: (*) Продвинутые задания на использование функций
//Задачи:
// //1) Создайте функцию, которая принимает в себя целое число минут и возвращает время в нужном формате строки. (Смотри пример). Обратите внимание на окончание слова "час" - оно меняется в зависимости от цифры. Если вместо аргумента приходит не число, дробное или отрицательное число - функция возвращает строку "Ошибка, проверьте данные"
// //Внимание! Давайте пока ограничимся максимум 600ю минутами (10 часов). Так как проверки на большие числа будут раздувать код (33 часа, 31 час, 11 часов и тд). Этого будет достаточно и код будет проверять именно этот промежуток (1 - 10 часов). Но вы можете реализовать и полный скрипт, он тоже должен проходить тесты.
// //Пример:
// //getTimeFromMinutes(150) => "Это 2 часа и 30 минут"
// //getTimeFromMinutes(50) => "Это 0 часов и 50 минут"
// //getTimeFromMinutes(0) => "Это 0 часов и 0 минут"
// //getTimeFromMinutes(-150) => "Ошибка, проверьте данные"


// function getTimeFromMinutes(minutesTotal) {
//     if (typeof(minutesTotal) !== 'number' || minutesTotal < 0 || !Number.isInteger(minutesTotal)) {
//         return "Ошибка, проверьте данные";
//     }

//     const hours = Math.floor(minutesTotal / 60);
//     const minutes = minutesTotal % 60;

//     let hoursStr = '';

//     switch (hours) {
//         case 0:
//             hoursStr = 'часов';
//             break;
//         case 1:
//             hoursStr = 'час';
//             break;
//         case 2:
//         case 3:
//         case 4:
//             hoursStr = 'часа';
//             break;
//         default:
//             hoursStr = 'часов';
//     }

//     return `Это ${hours} ${hoursStr} и ${minutes} минут`;
// }

// console.log(getTimeFromMinutes(180)); //Это 3 часа и 0 минут



// //2) Напишите функцию, которая принимает в себя 4 числа и возвращает самое большее из них. Если один из аргументов не является числом или их меньше 4 - возвращается 0. Дробные числа разрешены.
// //Пример:
// //findMaxNumber(1, 5, 6.6, 11); =>  11
// //findMaxNumber(1, 5, '6', '10');  =>  0

// function findMaxNumber(a, b, c, d) {
//     if (typeof(a) !== 'number' ||
//         typeof(b) !== 'number' ||
//         typeof(c) !== 'number' ||
//         typeof(d) !== 'number') {
//         return 0;
//     } else {
//         return Math.max(a, b, c, d);
//     }
// }

// console.log(findMaxNumber(1, 5, 6.6, 10.5));//10.5
// console.log(findMaxNumber(1, 5, '6', '10'));//0



// //(**) Задача с собеседований на числа Фибоначчи
// //числа Фибоначчи, где первые два числа равны 0 и 1, а каждое последующее число равно сумме двух предыдущих чисел. 
// //решение БЕЗ рекурсии
// //Задача:
// //Создайте функцию, которая будет принимать в себя один аргумент-целое положительное число. Она должна возвращать строку, в которой будут через пробел выведены числа Фибоначчи. Причем, их количество должно быть равно переданному аргументу. Если переданный аргумент не число - вернуть пустую строку. Решать без применения рекурсии.
// //Пример:
// //fib(4) => ''0 1 1 2"
// //fib(7) => ''0 1 1 2 3 5 8"
// //fib('7') => ''"
// //fib(1) => "0"
// //fib(0) => ''"

// function fib(num) {
//     if (typeof(num) !== 'number' || num <= 0 || !Number.isInteger(num)) {
//         return "";
//     }

//     let result = '';
//     let first = 0;
//     let second = 1;

//     for (let i = 0; i < num; i++) {
//         if (i + 1 === num) {
//             result += `${first}`; //без пробела вконце
//         } else {
//             result += `${first} `;//с пробелом вконце
//         }

//         let third = first + second;
//         first = second;
//         second = third;
//     }

//     return result;
// }

// console.log(fib(5));//0 1 1 2 3



// //l.31 callback-функции

// function first() {
//     //Do something
//     setTimeout(function() {
//         console.log(1);
//     }, 500);
// }

// function second() {
//     console.log(2);
// }

// first();
// second();
// //2
// //1
// //то есть вначале выполняется вторая функция, а потом задержка на 500миллисекунд/1000=0,5секунд и выполняется первая функция, то есть запускаются одна за другой, но результат могут отдать в разное время
// //колбэк - функция которая должна быть выполнена после того как другая функция завершила свое выполнение 

// function learnJS(lang, callback) {
//     console.log(`Я учу: ${lang}`);
//     callback();
// }

// learnJS('JavaScript', function() {
//     console.log('Я прошла этот урок!');
// });
// // учу: JavaScript
// //Я прошла этот урок!



// function learnJS(lang, callback) {
//     console.log(`Я учу: ${lang}`);
//     callback();
// }

// function done() {
//     console.log('Я прошла этот урок!!');
// }

// learnJS('JavaScript', done);
// //Я учу: JavaScript
// //Я прошла этот урок!!



//l.32 Объекты, деструктуризация объектов (ES6)

// const options = {
//     name: 'test',
//     width: 1024,
//     height: 1024,
//     colors: {
//         border: 'black',
//         bg: 'red'
//     }
// };

//console.log(options.name);//test

// delete options.name; //удалить свойство name объекта options
// console.log(options); //{ width: 1024, height: 1024, colors: { border: 'black', bg: 'red' } }

//перебрать все свойства объекта конструкция фор ин
//ключевое слово for в круглых кнопках настроить наш цикл здесь мы укажем в какой объекте мы будем перебирать эти свойства и как каждое свойство нам назвать общее слово key ключ (ключ-значение) чтобы перебирать ключи переменная key и будем копаться внутри options раскрываем конструкцию и задаем что будет выполняться цикл будет работать столько раз сколько свойств внутри объекта выводим в консоль конструкцию свойство перебираем каждое отдельное свойство key имеет значение что за значение находится в свойстве key - пользуемся конструкцией работаем в объете опшинс значение этого ключа который перебирается в этом повторении цикла
//`` бэктики

//for (let key in options) {
//    console.log(`Свойство ${key} имеет значение ${options[key]}`);
//}
//ответ: 
//Свойство name имеет значение test
//Свойство width имеет значение 1024
//Свойство height имеет значение 1024
//Свойство colors имеет значение [object Object]

//свойство for (let key of options) {} - для объектов работать не будет
//[object Object]- сейчас все значения выводим в качестве строк, но одно из свойств объекта тоже является объектом, когда код натыкается на такой объем он не может его превратить в строку и в вывод выводит такую структуру (строковое представление объекта) не ошибка, а объект который код не может превратить в строчку



// for (let key in options) {
//     if (typeof(options[key]) === 'object') {
//         for (let i in options[key]) {
//             console.log(`Свойство ${i} имеет значение ${options[key][i]}`);
//         }
//     } else {
//         console.log(`Свойство ${key} имеет значение ${options[key]}`);
//     }
// }
// // console.log(options["colors"]["border"]);//black
// //элз - если ключ наш не будет объектом то мы просто выводим так как это было раньше
// //ответ:
// // Свойство name имеет значение test
// // Свойство width имеет значение 1024
// // Свойство height имеет значение 1024
// // Свойство border имеет значение black
// // Свойство bg имеет значение red


// let counter = 0;
// for (let key in options) {
//     if (typeof(options[key]) === 'object') {
//         for (let i in options[key]) {
//             console.log(`Свойство ${i} имеет значение ${options[key][i]}`);
//             counter++;
//         }
//     } else {
//         console.log(`Свойство ${key} имеет значение ${options[key]}`);
//         counter++;
//     }
// }
// console.log(counter);
// //посчитаем количество свойств с помощью цикла
// //ответ:
// //Свойство name имеет значение test
// //Свойство width имеет значение 1024
// //Свойство height имеет значение 1024
// //Свойство border имеет значение black
// //Свойство bg имеет значение red
// //5-потому что считывает 2 уровень вложенности (name, width, height, border, bd) - и внутри for есть counter и внутри else, если оставить только в else - будет считать только первый уровень name, width, height, colors и выдаст результат - 4



// let counter = 0;
// for (let key in options) {
//     if (typeof(options[key]) === 'object') {
//         for (let i in options[key]) {
//             console.log(`Свойство ${i} имеет значение ${options[key][i]}`);
//         }
//     } else {
//         console.log(`Свойство ${key} имеет значение ${options[key]}`);
//         counter++;
//     }
// }
// console.log(counter);
// //ответ 3
// //что-то пошло не так, программа начала считать: name width height - уткнулась в объект и пошла по другому разветвлению условия if  выдала результат

// //классический способ узнать количество ключей
// let counter = 0;
// for (let key in options) {
//     counter++;
// }
// console.log(counter);
// //ответ 4
// //но это не удобно, есть метод:

// console.log(Object.keys(options));
// //[ 'name', 'width', 'height', 'colors' ] //получаем массив с ключами
// //у массива есть свойство length-узнать количество элементов


// console.log(Object.keys(options).length);
// //4



// //методы это действия которые умеет совершать наш объект
// const options = {
//     name: 'test',
//     width: 1024,
//     height: 1024,
//     colors: {
//         border: 'black',
//         bg: 'red'
//     },
//     makeTest: function() {
//         console.log("Test");
//     }
// };
// options.makeTest();
// //Test

//объекты - структуры которые могут сохранять в себе любые типы данных в формате ключ-значение, они также могут быть вложенные объекты в объекты, массивы в объекты и тд. чтобы их перебрать можем использовать конструкцию фор ин и делать что угодно с ключами key и значениями. получать свойства можем через точку или квадратные скобки. у объектов бывают встроенные методы и встроенные свойства, чтобы объект что-то умел мы можем внутрь него записывать функции и таким образом создавать методы нашего объекта. свойства акцессоры - гэт и сэт, деструктуризация объекта

// //деструктуризация объекта - достучаться до вложенных свойств:
// const {border, bg} = options.colors;
// //переменная {те переменные которые хочу вытащить} присвоить ту структура из которой хочу сделать более мелкие кусочки из свойства option colors
// console.log(border);//black

//джаваскрипт считается объектно-ориентированным языком и все сущности которые в нем есть сводятся к объектам. но правильнее считать прототипно-ориентрованным



// let number = 1;
// //console.log(--number);//0-отдельно
// //console.log(number++);//1-отдельно
// //console.log(++number);//2-отдельно

// console.log(--number);//0-подряд
// console.log(number++);//0-подряд
// console.log(++number);//2-подряд


//урок 33. Массивы и псевдомассивы

//const arr = [1, 2, 3, 6, 8]; //массив набор чисел

//arr.pop();//[ 1, 2, 3, 6 ] метод удаляет последний элемент массива
//arr.push(10);//[ 1, 2, 3, 6, 8, 10 ] метод добавляет элемент (в скобках что добавить)
//console.log(arr);
//чтобы добавить в начало элемент не достаточно его вписать, еще и у последнующих ранее вставленных элементов меняются индексы 0=1, 1=2, 2=3, 3=6, 4=8

// for (let i = 0; i < arr.length; i++) {
//     console.log(arr[i]);
// }
// //1
// //2
// //3
// //6
// //8


// for (let value of arr) {
//     console.log(value);
// }
// //1
// //2
// //3
// //6
// //8
// //конструкция for of работает только с массиво подобными сущностями, с помощью фор оф нельзя перебрать объекты, но можно: массив, строку, псевдомассивы, мэп и сэт.
//можно использовать break, continue


//console.log(arr.length);//5-длина массива
// arr[99] = 0;
// console.log(arr.length);//100 отому что свойство лэнг происходит от последнего индекса плюс 1
// console.log(arr); //[ 1, 2, 3, 6, 8, <94 empty items>, 0 ] //нарушение, элементы лежат не по порядку



// arr.forEach(function(item, i, arr) {
//     console.log(`${i}: ${item} внутри массива ${arr}`);
// });
// //0: 1 внутри массива 1,2,3,6,8
// //1: 2 внутри массива 1,2,3,6,8
// //2: 3 внутри массива 1,2,3,6,8
// //3: 6 внутри массива 1,2,3,6,8
// //4: 8 внутри массива 1,2,3,6,8
// //метод позволяет отдельно задать класс разным элементам
// //break, continue не работают



// const str = prompt("", "");
// const products = str.split(", ");
// console.log(products);
// //промпт в консоли вскода не работает, только всплывающими окнами в браузере
// //всплывает окно, в нем я ввожу товары через запятую: qqq, www, eee окей и открываю консоль которая возвращает массив array 
// //0: "qqq"
// //1: "www"
// //2: "eee"


// //метод join объединение элементов в массив и разделитель в скобочках с помощью которого будут выводиться элементы
// const str = prompt("", "");
// const products = str.split(", ");
// console.log(products.join('; '));
// //в всплывающем на странице окне ввожу www, www, rrr, vvv
// //в консоли мне отвечают: www; www; rrr; vvv

//метод сорт
// const str = prompt("", "");
// const products = str.stlit(", ");
// products.sort();
// console.log(products.join('; '));
// //в всплывающем окне на странице ввожу qqq, aaa, bbb нажимаю окей и в консоли:
// // aaa; bbb; qqq
// //строчные элементы сортируются по алфавиту

// const arra = [2, 13, 26, 8, 10];
// arra.sort();
// console.log(arra);
// //[ 10, 13, 2, 26, 8 ]
// //очень странная сортировка, каждое число которое начинается с единички встало на первое место 10 и 13 по первому символу равны дальше 0 и 3 - 0 идет перед 3

// const arra = [2, 13, 26, 8, 10];
// arra.sort(compareNum);
// console.log(arra);

// function compareNum(a, b) {
//     return a - b;
// }
// //[ 2, 8, 10, 13, 26 ]




//урок 35 передача по ссылке и по значению, spread оператор (ES6-ES9)

// let a = 5,
//     b = a;
// b = b + 5;
// console.log(b);//10
// console.log(a);//5



// const obj = {
//     a: 5,
//     b: 1
// };
// const copy = obj;//ссылку
// copy.a = 10;
// console.log(copy);//{ a: 10, b: 1 }
// console.log(obj);//{ a: 10, b: 1 }
// //не получилось. а как копировать объект?



// function copy(mainObj) {
//     let objCopy = {};
//     let key;
//     for (key in mainObj) {
//         objCopy[key] = mainObj[key];
//     }
//     return objCopy;
// }
// const numbers = {
//     a: 2,
//     b: 5,
//     c: {
//         x: 7,
//         y: 4
//     }
// };
// const newNumbers = copy(numbers);
// newNumbers.a = 10;
// console.log(newNumbers);//{ a: 10, b: 5, c: { x: 7, y: 4 } }
// console.log(numbers);//{ a: 2, b: 5, c: { x: 7, y: 4 } }
//a - поменялось



// function copy(mainObj) {
//     let objCopy = {};
//     let key;
//     for (key in mainObj) {
//         objCopy[key] = mainObj[key];
//     }
//     return objCopy;
// }
// const numbers = {
//     a: 2,
//     b: 5,
//     c: {
//         x: 7,
//         y: 4
//     }
// };
// const newNumbers = copy(numbers);
// newNumbers.a = 10;
// newNumbers.c.x = 10;
// console.log(newNumbers);//{ a: 10, b: 5, c: { x: 10, y: 4 } }
// console.log(numbers);//{ a: 2, b: 5, c: { x: 10, y: 4 } }
// //a - поменялось
// //x внутри c - перезаписалось в старом и новом при том что в старом было записано 7
// //когда копируем объекты есть глубокие и поверхностные копии объектов
// //сейчас создали поверхностную копию
// //потом научимся создавать глубокую копию чтобы изменять скопированный объект



// //Метод Object. assign() используется для копирования свойств из одного или нескольких объектов в объект, переданный в метод первым аргументом.
// //соединить два объекта в один
// const numbers = {
//     a: 2,
//     b: 5,
//     c: {
//         x: 7,
//         y: 4
//     }
// };
// const add = {
//     d: 17,
//     e: 20
// };
// // console.log(Object.assign(numbers, add));
// // //{ a: 2, b: 5, c: { x: 7, y: 4 }, d: 17, e: 20 }
// const clone = Object.assign({}, add);
// clone.d = 33;
// // console.log(add);//{ d: 17, e: 20 }
// // console.log(clone);//{ d: 33, e: 20 }



// const oldArray = ['a', 'b', 'c'];
// const newArray = oldArray.slice();
// newArray[1] = 'asdfghj';
// console.log(newArray);//[ 'a', 'asdfghj', 'c' ]
// console.log(oldArray);//[ 'a', 'b', 'c' ]



// spread оператор или оператор разворота
//1 вариант:
// const video = ['youtube', 'vimeo', 'rutube'],
//       blogs = ['wordpress', 'livejournal', 'blogger'],
//       internet = [...video, ...blogs, 'vk', 'facebook'];
// console.log(internet);
// //[
// //    'youtube',
// //    'vimeo',
// //    'rutube',
// //    'wordpress',
// //    'livejournal',
// //    'blogger',
// //    'vk',
// //    'facebook'
// //  ]
//2 вариант:
// function log(a, b, c) {
//     console.log(a);
//     console.log(b);
//     console.log(c);
// }
// const num = [2, 5, 7];
// log(...num);
// //2
// //5
// //7
//3 вариант:
// const array = ["a", "b"];
// const newArray = [...array];
// console.log(array);//[ 'a', 'b' ]
// console.log(newArray);//[ 'a', 'b' ]
//4 вариант:
// const objQ = {
//     one: 1,
//     two: 2
// };
// const newObjQ = {...objQ};
// console.log(objQ);//{ one: 1, two: 2 }
// console.log(newObjQ);//{ one: 1, two: 2 }



// //упражнение по написанию кода 10: задачи на работу с объектами
// //Задачи:
// //1) Напишите функцию showExperience, которая будет принимать в себя объект со всеми данными и возвращать строку с опытом. 
// //Пример: showExperience(personalPlanPeter) => '1 month'
// //желательно использовать деструктуризацию, но не обязательно
// //2) Напишите функцию showProgrammingLangs, которая будет принимать в себя объект со всеми данными и возвращать строку в нужном виде.
// //Пример: showProgrammingLangs(personalPlanPeter)  => "Язык js изучен на 20% Язык php изучен на 10%"
// //Причем функция должна работать вне зависимости от количества языков. Если ни один не указан, то возвращается пустая строка. Для переноса строки используется \n в конце строки.
// //3) Создайте метод showAgeAndLangs внутри объекта personalPlanPeter. При его вызове метод будет принимать в себя объект и возвращать строку в нужном виде.
// //Пример: personalPlanPeter.showAgeAndLangs(personalPlanPeter) => 'Мне 29 и я владею языками: RU ENG'
// //Заметьте, что возраст и языки подставляются автоматически из объекта, а языки всегда в верхнем регистре (большими буквами). Если данные в объекте поменяются, то и сообщение тоже изменится.

// const personalPlanPeter = {
//     name: "Peter",
//     age: "29",
//     skills: {
//         languages: ['ru', 'eng'],
//         programmingLangs: {
//             js: '20%',
//             php: '10%'
//         },
//         exp: '1 month'
//     },
//     showAgeAndLangs: function(plan) {
//         const {age} = plan;
//         const {languages} = plan.skills;
//         let str = `Мне ${age} и я владею языками: `;

//         languages.forEach(function(lang) {
//             str += `${lang.toUpperCase()} `;
//         });

//         return str;
//     }
// };

// console.log(personalPlanPeter.showAgeAndLangs(personalPlanPeter)); //Мне 29 и я владею языками: RU ENG 

// function showExperience(plan) {
//     const {exp} = plan.skills;
//     return exp;
// }

// console.log(showExperience(personalPlanPeter)); //1 month

// function showProgrammingLangs(plan) {
//     let str = '';
//     const {programmingLangs} = plan.skills;
//     for (let key in programmingLangs) {
//         str += `Язык ${key} изучен на ${programmingLangs[key]}\n`
//     }
//     return str;
// }

// console.log(showProgrammingLangs(personalPlanPeter));
// //Язык js изучен на 20%
// //Язык php изучен на 10%



//упражнение по написанию кода 11: задачи на работу с массивами
//Задачи:
// //1) Напишите функцию showFamily, которая будет принимать в себя массив строк и возвращать сообщение в нужном формате.
// //showFamily(family)  => 'Семья состоит из: Peter Ann Alex Linda'
// //Имена подставляются автоматически из массива. Если массив пустой, то выводится сообщение 'Семья пуста'
// const family = ['Peter', 'Ann', 'Alex', 'Linda'];
// function showFamily(arr) {
//     let str = '';
//     arr.length === 0 ? str = 'Семья пуста' : str = 'Семья состоит из: ';
//     arr.forEach(member => {
//         str += `${member} `
//     });
//     return str;
// }
// console.log(showFamily(family));//Семья состоит из: Peter Ann Alex Linda 


// //2) напишите функцию standardizeStrings, которая будет принимать в себя массив строк и будет выводить в консоль эти строки в нижнем регистре.
// //Пример:
// //standardizeStrings(favoriteCities)  выведет в консоль
// //lisbon
// //rome
// //milan
// //dublin
// const favoriteCities = ['liSBon', 'ROME', 'miLan', 'Dublin'];
// function standardizeStrings(arr) {
//     arr.forEach(city => {
//         console.log(city.toLowerCase())
//     })
// }
// console.log(standardizeStrings(favoriteCities));
// //lisbon
// //rome
// //milan
// //dublin
// //undefined



// упражнение по написанию кода 12 задачи на работу с массивами часть 2
// 3) Задача с собеседований. Напишите функцию reverse, которая принимает в себя строку и возвращает эту строку в обратном порядке.
// Пример:
// const someString = 'This is some strange string';
// reverse(someString) => 'gnirts egnarts emos si sihT'
// Функцию можно применить к любой строке. Если в функцию приходит не строка - вернуть сообщение "Ошибка!"
// Метод reverse() на месте обращает порядок следования элементов массива. Первый элемент массива становится последним, а последний — первым.

// //Оптимальный вариант решения:
// const someString = 'This is some strange string';
// function reverse(str) {
//     if (typeof(str) !== 'string') {
//         return "Ошибка!";
//     }
//     return str.split('').reverse().join('');
// }
// console.log(reverse(someString));//gnirts egnarts emos si sihT

// //решение при помощи цикла:
// const someString = 'This is some strange string';
// function reverse(str) {
//     let newStr = '';
//     for (let i = str.length - 1; i >= 0; i--) {
//         newStr += str[i];
//     }
//     return newStr
// }
// console.log(reverse(someString));//gnirts egnarts emos si sihT



// 4) Представьте такую реальную ситуацию. У вас есть банкомат, который выдает деньги из двух разных банков в разных валютах. Один банк основной с базовыми валютами, второй дополнительный с прочими валютами:
// const baseCurrencies = ['USD', 'EUR'];
// const additionalCurrencies = ['UAH', 'RUB', 'CNY'];
// Вам нужно создать главную функцию банкомата availableCurr, которая принимает два аргумента: первый - это массив со всеми доступными валютами из двух банков сразу (сейчас представим, что они не могут повторяться), второй - необязательный аргумент, который указывает ту валюту, которая сейчас закончилась в банкомате. Если массив в первом аргументе пустой - то функция возвращает строку 'Нет доступных валют'. Функция возвращает строку в нужном виде.
// Пример:
// availableCurr(['UAH', 'RUB', 'CNY'], 'CNY')
// Вернет строку:
// Доступные валюты:
// UAH
// RUB
// Заметьте:
// - CNY (юань) исчез из списка валют, значит такая валюта закончилась
// - После валюты: стоит перенос строки \n, и после каждой валюты тоже. Это важно для тестов
// - Данные для первого аргумента должны приходить сразу из двух банков, причем сначала baseCurrencies, потом additionalCurrencies по порядку

// //оптимальное решение:
// const baseCurrencies = ['USD', 'EUR'];
// const additionalCurrencies = ['UAH', 'RUB', 'CNY'];
// function availableCurr(arr, missingCurr) {
//     let str = '';
//     arr.length === 0 ? str = 'Нет доступных валют' : str = 'Доступные валюты:\n';
//     arr.forEach(function(curr, i) {
//         if (curr != missingCurr) {
//             str += `${curr}\n`;
//         }
//     });
//     return str;
// }
// console.log(availableCurr([...baseCurrencies, ...additionalCurrencies], 'CNY'))
// //Доступные валюты:
// //USD
// //EUR
// //UAH
// //RUB

// //с помощью цикла фор
// const baseCurrencies = ['USD', 'EUR'];
// const additionalCurrencies = ['UAH', 'RUB', 'CNY'];
// function availableCurr(arr, missingCurr) {
//     let str = '';
//     arr.length === 0 ? str = 'Нет доступных валют' : str = 'Доступные валюты:\n';
//     for (let i = 0; i < arr.length; i++) {
//         if (arr[i] === missingCurr) {
//             continue;
//         }
//         str += `${arr[i]}\n`;
//     }
//     return str;
// }
// console.log(availableCurr([...baseCurrencies, ...additionalCurrencies], 'CNY'));
// //Доступные валюты:
// //USD
// //EUR
// //UAH
// //RUB



// //упражнение по написанию кода 13: (*) Продвинутая задача на работу с объектами и массивами
// //Задача:
// //У вас есть небольшой кусочек данных о торговом центре, которые записаны в объекте shoppingMallData. Они содержат массив с данными о магазинах, где указана длина и ширина помещения; высоту помещения; стоимость отопления за 1 кубический метр и бюджет на оплату отопления за месяц.
// //Основная задача - это написать функцию isBudgetEnough, которая будет возвращать строку. Если бюджета хватает для отопления всего объема торгового центра - выводится 'Бюджета достаточно', если нет - 'Бюджета недостаточно'. И все 
// //Но эта задача содержит несколько подзадач внутри:
// //- вычисление общей площади всех магазинов, которая вычисляется как длина магазина, умноженная на его ширину;
// //- вычисление общего объема торгового центра, так как цена отопления указана в кубических метрах;
// //- определение того, хватает ли бюджета на оплату такого объема;
// //- все числа идут без единиц измерения для упрощения, просто цифры и все;
// //- функция должна продолжать работать, даже если изменяется количество магазинов, высота, бюджет или подставляется вообще другой объект.

// const shoppingMallData = {
//     shops: [
//         {
//             width: 10,
//             length: 5
//         },
//         {
//             width: 15,
//             length: 7
//         },
//         {
//             width: 20,
//             length: 5
//         },
//         {
//             width: 8,
//             length: 10
//         }
//     ],
//     height: 5,
//     moneyPer1m3: 30,
//     budget: 50000
// }

// function isBudgetEnough(data) {
//     let square = 0;
//     let volume = 0;

//     data.shops.forEach(shop => {
//         square += shop.width * shop.length;
//     });

//     volume = data.height * square;

//     if (data.budget - (volume * data.moneyPer1m3) >= 0) {
//         return 'Бюджета достаточно';
//     } else {
//         return 'Бюджета недостаточно';
//     }
// }

// console.log(isBudgetEnough(shoppingMallData));//Бюджета недостаточно

// //есть объект shoppingMallData
// //в массиве данные: ширина и длина помещения (разные)
// //высота помещения (одинаковая у всех)
// //стоимость отопления за метр
// //бюджет на всех

// //надо посчитать: достаточно или нет бюджета

// //длина*ширина=площадь магазина и все сложить
// //(10*5)+(15*7)+(20*5)+(8*10)=335 это square
// //volume=5*335=1675
// //плата: 1675*30=50250 - бюджет 50000 т.е. бюджета не достаточно

// //объявляю переменную площадь
// //объявляю переменную объем

// //последовательно перебрать все элементы массива и умножить ширину на длину += присваивание со сложением

// //чтобы получить объем умножаю высоту на площадь

// //если (бюджет - (объем*цену)) больше или равно 0 значит бюджета достаточно, если меньше 0 - бюджета не достаточно

// //вызов функции



// //упражнение по написанию кода 14: (*) продвинутая задача на работу с объектами и массивами
// //Задача:
// //У вас есть список учеников, которые хотят поиграть в игру:
// //const students = ['Peter', 'Andrew', 'Ann', 'Mark', 'Josh', 'Sandra', 'Cris', 'Bernard', 'Takesi', 'Sam'];
// //Но команд может быть только 3 по 3 человека. Напишите функцию sortStudentsByGroups, которая принимает в себя массив строк.
// //Внутри она сначала сортирует имена по алфавиту. 
// //Затем распределяет учеников по 3 человека в 3 группы по алфавитному порядку.
// //Эти группы должны быть массивами. 
// //Как итог, функция возвращает новый массив с тремя командами и строкой как 4й элемент.
// //Пример:
// //sortStudentsByGroups(students)  =>
// //[
// //  [ 'Andrew', 'Ann', 'Bernard' ],
// //  [ 'Cris', 'Josh', 'Mark' ],
// //  [ 'Peter', 'Sam', 'Sandra' ],
// //  'Оставшиеся студенты: Takesi'
// //]
// //Если убрать одно студента из списка, то результат будет:
// //[
// //    [ 'Andrew', 'Ann', 'Bernard' ],
// //    [ 'Cris', 'Josh', 'Mark' ],
// //    [ 'Peter', 'Sam', 'Sandra' ],
// //    'Оставшиеся студенты: -'
// //  ]
// //А если добавить одного, то:
// //  [
// //    [ 'Andrew', 'Ann', 'Bernard' ],
// //    [ 'Cris', 'Josh', 'Mark' ],
// //    [ 'Peter', 'Sam', 'Sandra' ],
// //    'Оставшиеся студенты: Takesi, Somebody'
// //  ]
// //То есть, меняется содержимое строки. Все оставшиеся ученики попадают туда.

// //метод sort - сортировка содержимого в вызванном массиве
// //rest остальные
// //метод push добавляет неограниченное количество элементов в конец массива - исходный массив меняется
// //метод join объединяет элементы массива в строку с указанным разделителем (он будет вставлен между элементами массива)


// const students = ['Peter', 'Andrew', 'Ann', 'Mark', 'Josh', 'Sandra', 'Cris', 'Bernard', 'Takesi', 'Sam'];
// function sortStudentsByGroups(arr) {
//     arr.sort();
//     const a = [], b = [], c = [], rest = [];

//     for (let i = 0; i < arr.length; i++) {
//         if (i < 3) {
//             a.push(arr[i]);
//         } else if (i < 6) {
//             b.push(arr[i]);
//         } else if (i < 9) {
//             c.push(arr[i]);
//         } else {
//             rest.push(arr[i]);
//         }
//     }
//     return [a,b,c, `Оставшиеся студенты: ${rest.length === 0 ? '-' : rest.join(', ')}`]
// }
// console.log(sortStudentsByGroups(students));
// //ответ:
// //[
// //    [ 'Andrew', 'Ann', 'Bernard' ],
// //    [ 'Cris', 'Josh', 'Mark' ],
// //    [ 'Peter', 'Sam', 'Sandra' ],
// //    'Оставшиеся студенты: Takesi'
// //  ]



// //урок 39 Динамическая типизация в JS
// //(превращение одних типов данных в другие)

// // To String - превратить в строку

// //1

// console.log(typeof(String(null)));//string

// console.log(String(null)); //null

// console.log(typeof(String(4)));//string

// //2 способ конкатенация сцепление

// console.log(typeof(5 + ''));//string

// console.log(typeof(null + ''));//string


// const num = 5;
// console.log("https://vk.com/catalog" + num); //https://vk.com/catalog5


// const fontSize = 26 + 'px';
// console.log(fontSize);//26px


// // To Number

// //1
// console.log(typeof(Number('4')));//number

// //2 способ унарный плюс
// console.log(typeof(+'5'));//number

// //3
// console.log(typeof(parseInt("15px", 10)));//number


// let answ = +prompt("Hello", "");//работает только в браузере

// // To boolean

// //пустота-false: 0, '', null, undefined, NaN

// //1 способ нативный
// let switcher = null;

// if (switcher) {
//     console.log('Working...');
// }//null=false ответа нет

// switcher = 1;

// if (switcher) {
//     console.log('Working...');
// }//1=true ответ: Working...

// //2 
// console.log(typeof(Boolean('4')));//boolean

// //3 - два знака отрицания !!
// console.log(typeof(!!"44444"));//boolean



// 41. Задачи с собеседований на понимание основ

// //1) Какое будет выведено значение: let x = 5; alert( x++ );
// let x = 5;
// //alert( x++ ); //5
// //alert( ++x ); //6


// //2) Чему равно такое выражение: //[ ] + false - null + true
// console.log([] + false);//false
// console.log([] + false - null);//NaN
// console.log([] + false - null + true);//NaN


// //3) Что выведет этот код: let y = 1; let x = y = 2; alert(x); 
// let y = 1;
// let x = y = 2;
// alert(x);//2


// //4) Чему равна сумма [ ] + 1 + 2
// console.log([] + 1 + 2);//12 -так как впереди массив возвращает строку


// //5) Что выведет этот код alert( "1"[0] )
// alert( "1"[0] );//1 -строка 1 индекс 0 выводит первый символ строки


// //6) Чему равно 
// //2 && 1 && null && 0 && undefined 

// //логическое И (&&) ЗАПИНАЕТСЯ НА ЛЖИ - ВЫШЕ ПРИОРИТЕТ ЧЕМ У ИЛИ
// //логическое ИЛИ (||) ЗАПИНАЕТСЯ НА ПРАВДЕ - НИЖЕ ПРИОРИТЕТ ЧЕМ У И

// console.log(2 && 1);//1
// console.log(1 && null);//null
// console.log(null && 0);//null
// console.log(0 && undefined);//0
// console.log(1 && undefined);//undefined
// console.log(null && undefined);//null
// console.log(2 && 1 && null && 0 && undefined);//null


// //7) Есть ли разница между выражениями? 
// //!!( a && b ) и (a && b)
// console.log(!!( 1 && 2 ) === (1 && 2));//false
// //(!!)динамическая типизация два знака !! превращает следующее выражение в булиновое в итоге булиновое выражение не будет ровняться значению которое вернется из соседнего выражения
// console.log(!! ( 1 && 2 ));//true
// console.log(1 && 2);//2
// //true неравно 2


// //8) Что выведет этот код: alert( null || 2 && 3 || 4 );
// alert( null || 2 && 3 || 4 );//3
// // //логическое И (&&) ЗАПИНАЕТСЯ НА ЛЖИ - ВЫШЕ ПРИОРИТЕТ ЧЕМ У ИЛИ
// console.log(2 && 3);//3 - 2 И 3 - тру и тру
// // //логическое ИЛИ (||) ЗАПИНАЕТСЯ НА ПРАВДЕ - НИЖЕ ПРИОРИТЕТ ЧЕМ У И
// console.log(null || 3);//3 - фолз или тру запинается на правде и возвращает правду
// console.log(3 || 4);//3 - тру или тру запинается на правде и возвращает первую правду


// //9) a = [1, 2, 3]; b = [1, 2, 3]; Правда ли что a == b 
// const a = [1, 2, 3]; //ящик с зелеными яблоками 
// const b = [1, 2, 3]; //двугой ящик с другими яблоками, но содержимое похоже
// console.log(a == b);//false


// //10) Что выведет этот код alert( +"Infinity" );
// alert( +"Infinity");//Infinity -это просто строчка, 
// //но унарный+ говорит что это тип данных число
// console.log(typeof(+"Infinity"));//number


// //11) Верно ли сравнение: "Ёжик" > "яблоко"?
// console.log("Ёжик" > "яблоко");//false
// //строки сравниваем - посимвольное сравнение
// console.log("яблоко" > "Ёжик");//true


// //12) Чему равно 
// //0 || "" || 2 || undefined || true || falsе
// // //логическое ИЛИ (||) ЗАПИНАЕТСЯ НА ПРАВДЕ
// console.log(0 || "" || 2 || undefined || true || false);//2
// //фолз ИЛИ фолз ИЛИ тру



// //Упражнение по написанию кода 15: Задания на поиск ошибок в коде (debug)
// //Задание:
// //У вас есть объект с данными о ресторане. Начинающий разработчик создал несколько функций, которые работают неправильно и он не может понять почему. Нужно исправить функции так, чтобы они давали всегда правильный результат.

// //1) Функция isOpen не хочет правильно работать. Что мы уже не пробовали подставлять в неё - результат все время неправильный. Необходимо найти причины и исправить.

// //2) Функция isAverageLunchPriceTrue должна брать цены двух любых блюд из меню, складывать их и сравнивать с средним чеком (averageLunchPrice).
// //Сейчас функция работает, но постоянно выдает неправильный результат. Ведь из представленного меню сумма двух любых цен всегда будет больше 20. Необходимо найти причину и исправить.

// //3) Функция transferWaitors создана для того, чтобы копировать шаблон данных и передавать их в другой ресторан. Конечно, в другом ресторане будут другие блюда, другие официанты и тп. Сейчас эта функция только в начале разработки и должна менять данные про официантов.
// //Но в нынешнем виде мы обнаружили, что после её запуска не только копия данных содержит новых официантов, но и основные данные! В restorantData сотрудник Alice исчезает и заменяется Mike! Необходимо найти причину и немедленно исправить, чтобы данные были разделены.

// const restorantData = {
//     menu: [
//         {
//             name: 'Salad Caesar',
//             price: '14$'
//         },
//         {
//             name: 'Pizza Diavola',
//             price: '9$'
//         },
//         {
//             name: 'Beefsteak',
//             price: '17$'
//         },
//         {
//             name: 'Napolean',
//             price: '7$'
//         }
//     ],
//     waitors: [
//         {
//             name: 'Alice',
//             age: 22
//         },
//         {
//             name: 'John',
//             age: 24
//         }
//     ],
//     averageLunchPrice: '20$',//средняя цена обеда
//     openNow: true//открыто сейчас
// };

// function isOpen(prop) {
//     let answer = '';
//     prop ? answer = 'Закрыто' : answer = 'Открыто';

//     return answer;
// }

// console.log(isOpen(restorantData.openNow));//не работало, добавила restorantData.//Закрыто



// //до исправления ошибок:
// // function isAverageLunchPriceTrue(fDish, sDish, average) {
// //     if (+fDish.price.slice(0, -1) + (sDish.price) < average) {
// //         return 'Цена ниже средней';
// //     } else {
// //         return 'Цена выше средней';
// //     }
// // }
// // console.log(isAverageLunchPriceTrue(restorantData.menu[0], restorantData.menu[1], restorantData.averageLunchPrice));//Цена ниже средней

// //после исправления ошибок
// function isAverageLunchPriceTrue(fDish, sDish, average) {
//     if (+fDish.price.slice(0, -1) + (+sDish.price.slice(0, -1)) < +average.slice(0, -1)) {
//         return 'Цена ниже средней';
//     } else {
//         return 'Цена выше средней';
//     }
// }
// console.log(isAverageLunchPriceTrue(restorantData.menu[0], restorantData.menu[1], restorantData.averageLunchPrice));//Цена выше средней
// //было (sDish.price) стало (+sDish.price.slice(0, -1))
// //было average стало +average.slice(0, -1))
// //код ДО работал, код ПОСЛЕ работает, изменился ответ



// function transferWaitors(data) {
//     const copy = Object.assign({}, data);
//     // copy.waitors[0] = {name: 'Mike', age: 32};//неправильно
//     copy.waitors = [{name: 'Mike', age: 32}];//правильно
//     return copy;
// }
// console.log(transferWaitors(restorantData));
// //ДО
// // {
// //     menu: [
// //       { name: 'Salad Caesar', price: '14$' },
// //       { name: 'Pizza Diavola', price: '9$' },
// //       { name: 'Beefsteak', price: '17$' },
// //       { name: 'Napolean', price: '7$' }
// //     ],
// //     waitors: [ { name: 'Mike', age: 32 }, { name: 'John', age: 24 } ],
// //     averageLunchPrice: '20$',
// //     openNow: true
// // }
// // ПОСЛЕ
// // {
// //     menu: [
// //       { name: 'Salad Caesar', price: '14$' },
// //       { name: 'Pizza Diavola', price: '9$' },
// //       { name: 'Beefsteak', price: '17$' },
// //       { name: 'Napolean', price: '7$' }
// //     ],
// //     waitors: [ { name: 'Mike', age: 32 } ],
// //     averageLunchPrice: '20$',
// //     openNow: true
// // }




//урок 43 Действия с элементами на странице
// const box = document.getElementById('box');
// console.log(box);//отображает элемент с айди box


// const btns = document.getElementsByTagName('button');
// console.log(btns);//отображает массив из всех кнопок
// если в хтмл оставить только одну кнопку, то все равно вернется массив но с одним значением

// const btns = document.getElementsByTagName('button')[1];
// console.log(btns);//отображает 2 элемент

// const btns = document.getElementsByTagName('button');
// console.log(btns[1]);//отображает 2 элемент


// const circles = document.getElementsByClassName('circle');//class-без точки
// console.log(circles);//возвращает массив всех circle


// const hearts = document.querySelectorAll('.heart');
// //console.log(hearts);//возвращает массив всех heart
// hearts.forEach(item => {
//     console.log(item);
// });//возвращает одно сердечко
//
// const oneHeart = document.querySelector('.heart');
// console.log(oneHeart);//возвращает одно сердечко

// const oneHeart = document.querySelector('div');
// console.log(oneHeart);//возвращает первый на странице див box

const box = document.getElementById('box'),
      btns = document.getElementsByTagName('button'),
      circles = document.getElementsByClassName('circle'),
      wrapper = document.querySelector('.wrapper'),
      hearts = wrapper.querySelectorAll('.heart'),
      oneHeart = wrapper.querySelector('.heart');

//console.dir(box);//получаем элемент в качестве объекта


// box.style.backgroundColor = 'blue'; //меняем элементу box цвет
// box.style.width = '500px';//меняем элементу box ширину
box.style.cssText = 'background-color: blue; width: 500px';


btns[1].style.borderRadius = '100%';//кнопка2 (индекс1) становится овальная
circles[0].style.backgroundColor = 'red';//окрасила первый кружок в красный цвет


// for (let i = 0; i < hearts.length; i++) {
//     hearts[i].style.backgroundColor = 'blue';
// }//окрасило фон сердечек так как сами сердечки созданы через after-before
//
hearts.forEach(item => {
    item.style.backgroundColor = 'blue';
});//работает точно также


const div = document.createElement('div');//существует только в js на странице не появится
//const text = document.createTextNode('Тут был я');


div.classList.add('black');//добавили див с классом блэк, но без document он не отобразиться на странице
document.body.append(div);//в конец бади создали див с классом black получили черный прямоугольник стили он взял из css
//document.querySelector('.wrapper').append(div);//в обертку wrapper добавился элемент див с классом блэк, но можно добавить его в переменные если он используется несколько раз const wrapper = document.querySelector('.wrapper');  тогда переписываем код:
//wrapper.append(div);
//wrapper.appendChild(div);//разницы нет
//wrapper.prepend(div);//черный прямоугольник перескакивает выше сердечек в блоке wrapper ИЛИ:
//hearts[0].before(div);//черный прямоугольник перед 1 сердечком
//hearts[0].after(div);//черный прямоугольник встал после первого красного сердечка
//wrapper.insertBefore(div, hearts[0]);//черный прямоугольник вставляю в начало wrapper
//wrapper.insertBefore(div, hearts[1]);//черный прямоугольник вставляю после первого сердечка


//circles[0].remove();//удалила первый кружочек
//wrapper.removeChild(hearts[1]);//удалила второе сердечко

hearts[0].replaceWith(circles[0]);//поменяла первое сердце на первый кружочек (кружочек перенесен на новое место)
//wrapper.replaceChild(circles[0], hearts[0]);//вместо 1 сердечка встает 1 кружочек. (вначале элемент который переставляют, потом на чье место)


//div.innerHTML = "Hello World";
div.innerHTML = "<h1>Hello World</h1>";//можно вставить хтмлкод на черный прямоугольник
//div.textContent = "Hello";//можно вставить текст на черный прямоугольник
//div.textContent = "<h1>Hello World</h1>";//текст на черном прямоугольнике: <h1>Hello World</h1>
//то для безопасности: иногда данные получаем от пользователя и если данные полученные от пользователя попадают в innerHTML это может повлиять на сайт и сломать верстку, поэтому пользователь может записывать информацию только в поле textContent



//div.insertAdjacentHTML("afterbegin", '<h2>Hello</h2>');//h2 идет ДО h1 ВНУТРИ обертки див блэк
//div.insertAdjacentHTML("beforeend", '<h2>Hello</h2>');//h2 идет ПОСЛЕ h1 ВНУТРИ обертки див блэк
//div.insertAdjacentHTML("beforebegin", '<h2>Hello</h2>'); //h2 идет ДО h1 ВНЕ обертки див блэк
//div.insertAdjacentHTML("afterend", '<h2>Hello</h2>');//h2 идет после h1 ВНЕ обертки див блэк

//урок 45 События и их обработчики
//событие - это сигнал от браузера, что что-то произошло(клик, двойной клик, наведение мыши, убрать мышь, прокрутка колесиком, отправка данных в форме, нажатие клавиш на клавиатуре) то что пользователь занимается на странице и есть событие и мы их можем отлавливать

//const btn = document.querySelector('button');//ЗАКОММЕНТИЛА КОГДА РАЗБИРАЛА querySelectorAll


// btn.onclick = function() {
//     alert('Click');
// };//УСТАРЕВШИЙ вариант-перезаписывается другим обработчиком
// btn.onclick = function() {
//     alert('Second click');
// };//при том, что есть первый обработчик, второй обработчик перезаписывает и при нажатии на кнопку - вылезает только второй алерт


//eventListener - слушатель события
// btn.addEventListener('click', () => {
//     alert('Click');
// });
// btn.addEventListener('click', () => {
//     alert('Second click');
// });//при клике появляется первый алерт, а за ним второй

//btn.addEventListener('mouseenter', (event) => {
    //alert('Hover');//при наведении на кнопку btn вылезает алерт на котором написано Hover
    //console.log('Hover');//при каждом наведении мышки на кнопку btn в консоли пишется Hover  счетчик
    //console.log(event);//возвращает объект который описывает что произошло с элементом на который навели мышку MouseEvent {isTrusted: true, screenX: 109, screenY: 137, clientX: 102, clientY: 9, …}
    //важное свойство type: "mouseenter" - тип события который произошел
    //важное свойство target: button#btn - элемент на котором произошло событие
    //console.log(event.target);//консоль возвращает <button id="btn">Нажми меня</button>
    //event.target.remove();//при наведении на кнопку она пропадает со страницы
    //если вместо 'mouseenter' написать 'click' - элемент пропадает при клике
//});


//delete
//let i = 0;
//const deleteElement = (event) => {
//    console.log(event.target);
//    i++;
//    if (i == 1) {
//        btn.removeEventListener('click', deleteElement);
//    }
//};
//btn.addEventListener('click', deleteElement);
//один ответ и больше ничего не происходит


//всплытие событий
const overlay = document.querySelector('.overlay');
const deleteElement = (event) => {
    console.log(event.target);
    //console.log(event.currentTarget);//другой способ таргета
    console.log(event.type);

};
//btn.addEventListener('click', deleteElement);//ЗАКОММЕНТИЛА КОГДА РАЗБИРАЛА querySelectorAll
//overlay.addEventListener('click', deleteElement);//ЗАКОММЕНТИЛА КОГДА РАЗБИРАЛА querySelectorAll
//при нажатии на кнопку в консоль я получаю два результата
//вначале событие сработало на том элементе которое идет вложеннее (кнопка)
//и после этого по иерархии вверх оно поднялось и уже сработала на розовой области overlay - это и называется всплытие событий
//когда данное действие срабатывает вначале на вложенном элементе и после этого поднимается наверх по иерархии нашего дом-дерева
//всплытие событий это когда обработчик событий сначала срабатывает на самом вложенном элементе, затем на родителе, и так выше и выше поднимаясь по иерархии 


//важно уметь отменять стандартное поведение в браузере 
const link = document.querySelector('a');
link.addEventListener('click', function(e) {
    e.preventDefault();
    console.log(e.target);
});//отменяет стандартное поведение браузера при нажатии на ссылку раньше переход на ютуб, а теперь в консоли ответ <a href="https://www.youtube.com/">https://www.youtube.com/</a>


// //querySelectorAll возвращает псевдомассив у которого нет метода addEventListener
// //если я делаю:
// const btns = document.querySelectorAll('button');
// btns.forEach(item => {
//     item.addEventListener('click', deleteElement, {once: true});
// });//теперь каждая кнопка работает
// //once - один раз аналог remove удаления после того как сработает
//закомментировала когда тестировала адаптивность - консоль ругается что btns несколько раз объявлена


//урок 47 рекурсия

// function pow(x, n) {
//     let result = 1;
//     for (let i = 0; i < n; i++) {
//         result *= x;//это result = result * x
//     }
//     return result;
// }//цикл

// function pow(x, n) {
//     if (n === 1) {
//         return x;
//     } else {
//         return x * pow(x, n - 1);
//     }
// }//рекурсия


// console.log(pow(2, 1));//2-два в первой степени
// console.log(pow(2, 2));//4
// console.log(pow(2, 3));//8
// console.log(pow(2, 4));//16


// let students = {
//     js: [{
//         name: 'John',
//         progress: 100
//     }, {
//         name: 'Ivan',
//         progress: 60
//     }],

//     html: {
//         basic: [{
//             name: 'Peter',
//             progress: 20
//         }, {
//             name: 'Ann',
//             progress: 18
//         }],

//         pro: [{
//             name: 'Sam',
//             progress: 10
//         }],

//         semi: {
//             students: [{
//                 name: 'Test',
//                 progress: 100
//             }]
//         }
//     }
// };

//посчитать средний прогресс студентов со всех курсов
// //цикл:
// function getTotalProgressByIteration(data) {
//     let totalProgress = 0;
//     let students = 0;

//     for (let course of Object.values(data)) {
//         if (Array.isArray(course)) {
//             students = students + course.length;
//             //students += course.length;

//             for (let i = 0; i < course.length; i++) {
//                 totalProgress = totalProgress + course[i].progress;
//                 //total += course[i].progress;
//             }
//         } else {
//             for (let subCourse of Object.values(course)) {
//                 students = students + subCourse.length;
//                 //students += subCourse.length;

//                 for (let i = 0; i < subCourse.length; i++) {
//                     totalProgress = totalProgress + subCourse[i].progress;
//                     //total += subCourse[i].progress;
//                 }
//             }
//         }
//     }

//     return totalProgress / students;
// }
// console.log(getTotalProgressByIteration(students));//41.6
// //цикл вначале что делаем с массивами, потом что делаем с объектами
// //course это общий массив - правая сторона студентс (js & html опускаются) остается name-john и тд 
// //этот код для структуры когда идет перебор массивов внутри объекта, если в список добавится объект то есть [], [], [], {} то надо добавлять еще условие внутри условия и так до бесконечности (тут помогает рекурсия)
// //рекурсия заносит в функцию повторяющееся части кода 


// //рекурсия:
// //if если массив, else если объект
// function getTotalProgressByRecursion(data) {
//     if (Array.isArray(data)) {
//         let totalProgress = 0;

//         for (let i = 0; i < data.length; i++) {
//             totalProgress = totalProgress + data[i].progress;
//         }

//         return [totalProgress, data.length];
//     } else {
//         let totalProgress = [0, 0];

//         for (let subData of Object.values(data)) {
//             const subDataArr = getTotalProgressByRecursion(subData);
//             totalProgress[0] = totalProgress[0] + subDataArr[0]; 
//             totalProgress[1] = totalProgress[1] + subDataArr[1];
//         }

//         return totalProgress;
//     }
// }

// const result = getTotalProgressByRecursion(students);

// //console.log(result[0]/result[1]);//41.6 - let без semi

// //обавила в let students внутрь html - semi
// //список массив, массив, объект
// //{{[][]{}}}
// // semi: {
// //     students: [{
// //         name: 'Test',
// //         progress: 100
// //     }]
// // }
// //первая функция с циклом расчитана на определенную структуру: обработает массив, массив, а потом поломается об объект

// //снова запускаем функцию рекурсию с учетом нового let

// console.log(result[0]/result[1]);//51.333333333333336
// //теперь функция работает с любой вложенностью сколько бы мы не добавляли структур



//упражнение по написанию кода 16:(*) Задача на рекурсию

//Напишите функцию, которая вычисляет факториал.
//Факториал  – это число, умноженное на "себя минус один", затем на "себя минус два", и так далее до 1. Факториал n обозначается как n!
//Отсюда мы можем понять, что функция должна принимать 1 аргумент, который будет являться числом. 
//Будет неплохо, если вы на собеседовании сразу напишите проверку на приходящее значение = если в нашу функцию приходит дробное число или не число  - возвращается строка с любым сообщением на ваше усмотрение. Если 0 и меньше - возвращается число 1.
//Сам же факториал с примерами выглядит вот так:
//n! = n * (n - 1) * (n - 2) * ...*1 - это общая формула
//Примеры значений для разных n:
//1! = 1
//2! = 2 * 1 = 2
//3! = 3 * 2 * 1 = 6
//4! = 4 * 3 * 2 * 1 = 24
//5! = 5 * 4 * 3 * 2 * 1 = 120
//То есть, вызов нашей функции factorial(5) возвращает число 120
//factorial(4) => 24
//Решить задачу нужно через рекурсию.
//Integer - Целое число


// function factorial(n) {
//     return n ? n * factorial(n - 1) : 1;
// }
// console.log(factorial(5));//120-короткий вариант
// console.log(factorial(-5));//ошибка-не учитывает отрицательные значения


function factorial(n) {
    if (typeof(n) !== 'number' || !Number.isInteger(n)) {
        return "Ошибка, проверьте данные";
    }

    if (n >= 1) {
        return n * factorial(n - 1);
    } else {
        return 1;
    }
}

console.log(factorial(5));//120
console.log(factorial(-5));//1



//урок 49. События на мобильных устройствах
//поддерживается только в мобильных браузерах
//события:
// 1) touchstart - событие выполняется при касании к элементу
// 2) touchmove - при движении пальца по элементу
// 3) touchend - когда палец отрывается от элемента
// 4) touchenter - срабатывает когда пальцем ведем и наскакиваем на элемент на который повешено событие
// 5) touchleave - срабатывает когда пальцем ведем и рошел за пределы элемента на который повешено событие
// 6) touchcancel - точка соприкосновения больше не регистрируется на поверхности(палец вышел за пределы браузера)

window.addEventListener('DOMContentLoaded', () => {
    const boxTouch = document.querySelector('.boxTouch');

    boxTouch.addEventListener('touchstart', (e) => {
        e.preventDefault();//отменяет стандартное поведение браузера

        console.log('Start');
        //console.log(e.touches);//ответ TouchList {0: Touch, length: 1} - 1 палец
        console.log(e.targetTouches);//почти тоже самое, через адаптивность нельзя смоделировать несколько пальцев
        console.log(e.changedTouches);//почти тоже самое, через адаптивность нельзя смоделировать несколько пальцев, но на мобильном устройстве все будет работать правильно: покажет список из пальцев которые коснулись элемента.
    });//при клике на область в консоли выводится старт и счетчик сколько раз клацнули

    boxTouch.addEventListener('touchmove', (e) => {
        e.preventDefault();//отменяет стандартное поведение браузера

        //console.log('Move');//тестирую targetTouches
        console.log(e.targetTouches[0].pageX);//при движении нажатого пальца в консоль выводится координата-координаты xy в дальшейшем можно задавать на какую часть слайдера по координатам пользователь должен нажать чтобы слайдер перелистнулся, но есть уже готовые библиотеки типа hammer.js 
    });//при нажатии и движении пальца по элементу в консоли выводится move и счетчик сколько раз передвинули палец

    boxTouch.addEventListener('touchend', (e) => {
        e.preventDefault();//отменяет стандартное поведение браузера

        console.log('End');
    });//при убирании пальца от элемента в консоли выводится end и счетчик сколько раз убрали палец
});

//три главных свойства при работе с сенсорными устройствами
//1) touches - св-во которое выдает нам список всех пальцев которые сейчас взаимодействуют с экраном (прямо сейчас тапнули и держат пользователи)
//чтобы увидеть пишу console.log(e.touches);
//ответ объект TouchList {0: Touch, length: 1} - 1 палец
//length - то количество пальцев
//target - с каким элементом произошло действие
//координаты xy в дальшейшем можно задавать на какую часть слайдера по координатам пользователь должен нажать чтобы слайдер перелистнулся
//2) targetTouches - св-во все пальцы которые взаимодействуют именно с этим элементом конкретным
//3) changedTouches - список пальцев которые участвуют в текущем событии. То есть если приложить 5 пальцев и при использовании touchEnd в списке будет 1 убранный палец даже если остальные 4 еще на экране.
//еще есть свайп, щепотка(зум)



//урок 50 
//как подключить script.js

function loadScript(src) {
    const script = document.createElement('script');
    script.src = src;
    script.async = false;
    document.body.append(script);
}

// loadScript("js/script.js"); почему-то здесь не подключает js в котором куча всего, только новые в которых 1 запись:
loadScript("js/some.js");
loadScript("js/test.js");